\documentclass{article}

%% for images
\usepackage{graphicx}
\graphicspath{ {images/} }

%% language support
\usepackage[T1,T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english,russian]{babel}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{geometry}
\geometry{margin=0.5in}

%% hyperrefs
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\title{2024}
\author{КЫК, [] и их друзья}

\begin{document}
\maketitle
\tableofcontents

\part{Чистка грамматики}
Грамматики могуть быть "плохими": там могут быть лишние символы, лишние правила

Такие граматики хочется упростить, и убрать из них всяческий мусор

\section{Исключение непорождающих переменных}
Переменная порождает строчку символов $A \in N^G$, если есть продукции вида: \\
\begin{enumerate}
  \item $ A \to w$, где $w \in L(T*)$
  \item $ A \to \alpha$, где $\alpha \in L(T\cup N^G)+$
\end{enumerate}
И на примере это выглядит так:

$T = \{a,b,c\}$ \\
$N = \{A,B,C,S\}$, S - стартовый \\
$P = \{ S \to AB, S \to C, A \to aA, A \to a, B \to bB, C \to c\}$

Действуем итерационно:
\begin{enumerate}
  \item Ищем правила первого типа (где справа только терминалы) - это: 
        $A \to a, C \to c$
            
    То есть $C, A$ уже можно записать в порождающие
    \item Теперь, когда базис собран - ищем правила второго типа 
    (те, где справа есть терминалы и уже найденные порождающие нетерминалы) - это:
    $S \to C, A \to aA, $ - то есть $S$ тоже можно записать в порождающие
    \item Итого, в наши порождающие символы в итоге попали $\{C,A,S\}$
    
    А вот $B$ ничего в итоге не порождает, а значит возможно он нам и не нужен?
\end{enumerate}

\section{Исключение недостижимых символов}
Попробуем пройти в другую сторону - от стартового символа
\begin{enumerate}
  \item $S$ - достижим
    \item $A \to \alpha$, если $A$ достижим, то все символы из $\alpha$ достижимы
\end{enumerate}
В общем-то достаточно логичный набор правил

Рассмотрим что получится на примере:

$ S \to AB, A \to C, C \to c, B \to bB, D \to aC, D \to bc$

$S$ достижим - значит $A, B$ достижимы\\
$A$ достижим - значит $C$ достижим\\
$B$ достижим - значит $b$ достижим\\
$C$ достижим - значит $c$ достижим\\

И остались недостижимыми $D, a$ - может они нам тоже не нужны?




\section{Полезные и бесполезные символы и продукции}
Собственно символ - \textbf{полезный} - если он используется в порождении какой-либо строки терминалов из стартового символа грамматики (ну в общем достижимый и порождающий)

А ещё бывают бесполезные продукции, и с ними надо подробнее разобраться

$A \to \varepsilon$ - это \textbf{эпсилон-продукция}\\
$A \to B$ - это \textbf{единичная продукция}\\

И есть одна интересная теоремка - если $L$ - контекстно-свободный язык, то $L - \{\varepsilon\}$ можно предствить в виде контекстно-свободной грамматики без эпсилон-продукций 

И есть из этой теоремки забавное следствие: Любой контекстно-свободный язык, содержащий пустую строку, можно представить контекстно-свободной грамматикой вида: 
$ G = <T, N, P \cup \{S\to \varepsilon \}, S>$, где $P$ не содержит эпсилон-продукций

\subsection{Избавляемся от эпсилон-продукций}
Идём дальше - теперь разберёмся с такой штукой как \textbf{зануляемый символ}, оно нам пригодится\\
Логично - что это символ $A$ такой что 
\begin{enumerate}
  \item $A \to \varepsilon$
    \item $A \to \alpha$, где $\alpha$ - строка из зануляемых символов
\end{enumerate}

А теперь... АЛГОРИТМ (хотя как завещала Бабалова - алгоритм был сначала)
\begin{enumerate}
  \item Находим зануляемые символы
    \item (могу сюда вставить честное определение, но....) Короче заменяем все продукции с зануляемыми символами на всевозможные варианты без них (потом на примере посмотреть надо)
    \item Исключаем все эпсилон-продукции, кроме той, что со стартовым символом слева
    \item Исключаем все бесполезные символы
\end{enumerate}

ПРИМЕР:
$S \to ABC, A \to aA| \varepsilon, C \to c | \varepsilon, B \to bB | A$
\begin{enumerate}
  \item Видно что зануляемыми у нас в итоге являются: $C, A, B, S$
    \item Вот тут начинается веселье\\
      $S \to ABC$ - заменяем на $ S \to ABC | BC | AC | AB | C | B | A | \varepsilon$ \\
        $A \to aA$ - заменяем на $A \to aA|a|\varepsilon$ \\
        $C \to c| \varepsilon$  - не не изменилось\\
        $B \to bB|A$ - заменяем на $B \to bB|A|b|\varepsilon$ \\
    \item В итоге остаются только:\\
        $ S \to ABC | BC | AC | AB | C | B | A | \varepsilon$ \\
        $A \to aA|a$ \\
        $C \to c$\\
         $B \to bB|A|b$ \\
\end{enumerate}

\subsection{Избавляемся от единичных продукций}
Теперь нам бы ещё надо избавиться от единичных продукций
\begin{enumerate}
  \item Продукции вида $A \to^* B$ и $B \to \alpha$ заменяем на $A \to \alpha$ - по сути просто сокращаем множество транзитивных переходов до одного
    \item (Исключаем все бесполезные символы)
\end{enumerate}




\section{Алгоритм очистки грамматики!!!}
\begin{enumerate}
\item Исключаем эпсилон-продукции
\item Исключаем единичные продукции
\item Исключаем все бесполезные символы
\item Ну и если стартовый символ зануляемый - оставялем $S \to \varepsilon$

\end{enumerate}
\part{Нормальная форма Хомского}
Грамматика является грамматикой в нормальной форме Хомского, если включает только продукции вида:
\begin{enumerate}
\item $A \to BC$, где $A, B, C \in N$
\item $A \to a$, где $A \in N, a \in T$
\end{enumerate}

И это очень строгие ограничения - и зачем оно нам вообще надо?

Ну в общем-то чтобы применить наш простой парсер КЯК

\section{Алгоритм построения CNF}
\begin{enumerate}
  \item Очистка грамматики -  и теперь  грамматике только продукции из 1 терминала или длина тела не меньше 2х
    \item Для каждого терминала создаём продукцию $A_a \to a$ и заменяем $a$ на $A_a$ во всех продукциях с длиной $\ge 2$ - и теперь у нас есть только продукции из 1 терминала или только из нетерминалов, длины $\ge 2$
     \item Ну и теперь заменяем все продукции с длиной $\ge 2$ на грамматики по такому алгоритму\\
      $A \to B\alpha $, где $|\alpha| \ge 2$ превращаем в $A \to BC$ и $C \to \alpha$
\end{enumerate}

\part{КЯК парсер}
Рассмотрим пример грамматики ниже. Возьмём для разбора строку $baaba$.
$$\ \ \ \ S \to AB \ | \ BC $$
$$A \to BA \ | \ a $$
$$B \to CC \ | \ b $$
$$C \to AB \ | \ a $$
Суть КЯК в рассмотрении подстрок от самых маленьких к целой строке. 
По итогу нам нужно узнать, является ли строка каким-то из нетерминалов 
(т.е. словом языка, порождённого грамматикой). Если совсем кратко -
принадлежит ли строка языку.
\\\\
Приступим к разбору. Ещё раз напомню, что мы его ведём снизу вверх - 
от терминалов к нетерминалам и так пока не охватим всю строку.
$$B \to b$$
$$A \to a$$
$$C \to a$$
Идём дальше. Это были подстроки длины 1. $baaba$ также имеет подстроки длины 2,
которые формируются из подстрок длины 1 ($\times$ - декартово произведение):
$$ba = b\times a = B \times A = BA = A$$
$$ba = b\times a = B \times C = BC = S$$
Пока у нас есть $A \to ba, S \to ba$. 
Которые получаются, как мы выяснили, вот так:
$$ A \to BA \to bA \to ba$$
$$ S \to BC \to bC \to ba$$
Тупо последовательно заменяем нетерминалы, пока не доберёмся до терминалов.
К сожалению, дальше мы упоремся и запутаемся, если будем так продолжать. 
Это была всего лишь первая 2-подстрока, а я уже устала.\\
Видимо, кто-то из авторов тоже устал, и придумал лестницу КЯК или как она там. 
Выглядит она следующим образом (цифры - длины подстрок, НТ - нетерминалы):\\
\begin{center}
    \begin{tabular}{ c|c c c c c }
    5 & НТ \\ 
    4 & НТ & НТ  \\  
    3 & НТ & НТ & НТ   \\  
    2 & НТ & НТ & НТ & НТ  \\  
    1 & НТ & НТ & НТ & НТ & НТ  \\
    \hline
      & b  &  a &  a & b  &  a 
    \end{tabular}
\end{center}
Эта таблица показывает, из каких нетерминалов какую строку мы можем построить.
Пока что для нас она выглядит так:
\begin{center}
    \begin{tabular}{ c|c c c c c }
    5 & НТ  \\ 
    4 & НТ & НТ   \\  
    3 & НТ & НТ & НТ   \\  
    2 & НТ & НТ & НТ & НТ  \\  
    1 & B & A,C & A,C & B & A,C  \\
    \hline
      & b  &  a &  a & b  &  a 
    \end{tabular}
\end{center}
И, учитывая что мы уже успели проанализировать первое $ba$:
\begin{center}
    \begin{tabular}{ c|c c c c c }
    5 & НТ  \\ 
    4 & НТ & НТ   \\  
    3 & НТ & НТ & НТ   \\  
    2 & S,A & НТ & НТ & НТ  \\  
    1 & B & A,C & A,C & B & A,C  \\
    \hline
      & b  &  a &  a & b  &  a 
    \end{tabular}
\end{center}
Теперь давайте заполнять эту таблицу. Для следующих подстрок мы получим:
$$aa = a\times a = A,C \times A,C = AA, CA, AC, CC = B$$
$$ab = a\times b = A,C \times B = AB, CB = S, C$$
$$bb = b\times b = B \times B = \varnothing$$
\begin{center}
    \begin{tabular}{ c|c c c c c }
    5 & НТ \\ 
    4 & НТ & НТ   \\  
    3 & НТ & НТ & НТ   \\  
    2 & S,A & B & S,C & S,A  \\  
    1 & B & A,C & A,C & B & A,C  \\
    \hline
      & b  &  a &  a & b  &  a 
    \end{tabular}
\end{center}
Строки длины 3.
$$baa = b\times aa = B \times B = BB = \varnothing$$
$$baa = ba\times a = S,A \times A,C = SA, AA, SC, AC = \varnothing$$
$$aab = a\times ab = A,C \times S,C = AS, CS, AC, CC = B$$
$$aab = aa\times b = B \times B = \varnothing$$
$$aba = a\times ba = A,C \times S,A = AS, CS, AA, CA = \varnothing$$
$$aba = ab\times a = S,C \times A,C = SA, CA, SC, CC = B$$
\begin{center}
    \begin{tabular}{ c|c c c c c }
    5 & НT \\ 
    4 & НТ & НТ   \\  
    3 & $\varnothing$ & B & B   \\  
    2 & S,A & B & S,C & S,A  \\  
    1 & B & A,C & A,C & B & A,C  \\
    \hline
      & b  &  a &  a & b  &  a 
    \end{tabular}
\end{center}
Строки длины 4.
$$baab = b\times aab = B \times B = BB = \varnothing$$
$$baab = ba\times ab = S,A \times S,C = SS, AS, SC, AC = \varnothing$$
$$baab = baa\times b = \varnothing \times B = \varnothing$$
$$aaba = a\times aba = A,C \times B = AB, CB = S, C$$
$$aaba = aa\times ba = B \times S,A = BS, BA = A$$
$$aaba = aab\times a = B \times A,C = BA, BC = A,S$$
\begin{center}
    \begin{tabular}{ c|c c c c c }
    5 & НТ  \\ 
    4 & $\varnothing$ & S,A,C   \\  
    3 & $\varnothing$ & B & B   \\  
    2 & S,A & B & S,C & S,A  \\  
    1 & B & A,C & A,C & B & A,C  \\
    \hline
      & b  &  a &  a & b  &  a 
    \end{tabular}
\end{center}
Строки длины 5. 
$$baaba = b\times aaba = B \times S,A,C = BS, BA, BC = A, S$$
$$baaba = ba\times aba = S,A \times B = SA, AB = S,C$$
$$baaba = baa\times ba = \varnothing \times S,A = \varnothing$$
$$baaba = baab\times a = \varnothing \times A,C = \varnothing$$
\begin{center}
    \begin{tabular}{ c|c c c c c }
    5 & S,A,C  \\ 
    4 & $\varnothing$ & S,A,C   \\  
    3 & $\varnothing$ & B & B   \\  
    2 & S,A & B & S,C & S,A  \\  
    1 & B & A,C & A,C & B & A,C  \\
    \hline
      & b  &  a &  a & b  &  a 
    \end{tabular}
\end{center}
Таким образом, строка может быть получена путем последовательного раскрытия
(развертки) нетерминалов S, A, C.\\\\
УПРАЖНЕНИЕ. 
Убедиться, что все указанные нетерминалы преобразуются в искомую строку. 
\part{LL1 парсер}
Всё начинается с таблицы парсинга. Для составления таблицы необходимо вначале 
посчитать множества символов FIRST и FOLLOW для каждого нетерминала NT. 
\\Заметим, что первое правило грамматики для стартового нетерминала, 
если не указано иное. После стартового нетерминала может 
идти конец строки, для остальных в общем случае это неверно.
Рассмотрим следующую грамматику:
$$A \to CB $$
$$B \to +CB \ | \ \varepsilon $$
$$C \to ED $$
$$D \to *ED \ | \ \varepsilon$$
$$E \to id \ | \ (A)$$
FIRST(NT) - множество символов на первой позиции строки NT (aka begin()):\\
$$FIRST(A)=FIRST(C)$$
$$FIRST(B)=\ '+' \cup \ \varepsilon$$
$$FIRST(C)=FIRST(E)$$
$$FIRST(D)=\ '*' \cup \ \varepsilon$$
$$FIRST(E)=\ 'id' \cup \ '('$$
FOLLOW(NT) - множество символов на первой после последней
позиции строки NT (aka end()) (т.е.  \\ 
1) если видим $P \to ... NT \ Q$, то 
добавляем $FIRST(Q)$ (если $Q$ непусто) и $FOLLOW(P)$ \\
2) если $Q$ может быть $\varepsilon$, то добавляем $FOLLOW(Q)$ \\
3) $\varepsilon$ не может быть в FOLLOW, если появляется, то его надо убрать)
$$FOLLOW(A)=\ ')' \cup \ '\$' $$
$$FOLLOW(B)=FOLLOW(A)$$
$$FOLLOW(C)=FIRST(B) \cup FOLLOW(A) \cup FOLLOW(B)\ \setminus \varepsilon$$
$$FOLLOW(D)=FOLLOW(C) \ \setminus \varepsilon$$
$$FOLLOW(E)=FIRST(D) \cup FOLLOW(C) \cup FOLLOW(D)\ \setminus \varepsilon$$
Получм:\\
\begin{center}
  \begin{tabular}{ c|c|c }
    NT & FIRST & FOLLOW         \\
    \hline
    A &  id, ( & ), \$          \\
    \hline
    B &  +, $\varepsilon$ & ), \$    \\
    \hline
    C &  id, ( & +, ), \$       \\
    \hline
    D &  *, $\varepsilon$ & +, ), \$ \\
    \hline
    E &  id, ( & *, +, ), \$ 
  \end{tabular}
\end{center}
Теперь, таблица парсинга. Она содержит производящие правила на пересечении 
терминалов и нетерминалов. Заполняется
она так для каждого нетерминала NT:\\
1. Если $\varepsilon \in FIRST(NT)$, то пишем правило, которым 
получился $\varepsilon$, во всех строках из FOLLOW(NT).\\
2. Для всех прочих символов (не \$) из FIRST(NT)
в соответствующих столбцах пишется правило, которым этот символ был получен.
\begin{center}
  \begin{tabular}{ c|c|c|c|c|c|c }
    NT/T & id          & (            & + & ) & * & \$  \\
    \hline
    A    & $A \to CB $ & $A \to CB $  &   &   &   &     \\
    \hline
    B    &             &              &  $B \to +CB$ & $B \to \varepsilon$  &   & $B \to \varepsilon$     \\
    \hline
    C    & $C \to ED $ & $C \to ED $  &   &   &   &     \\
    \hline
    D    &             &              &  $D \to \varepsilon$ & $D \to \varepsilon$  &  $D \to *ED $ & $D \to \varepsilon$     \\
    \hline
    E    & $E \to id $ & $E \to (A) $ &   &   &   &     \\
  \end{tabular}
\end{center}
Удивительно, но алгоритм предельно прост. Мы всего лишь инициализируем 
стек стартовым нетерминалом, а в конец рассматриваемой строки добавляем
конечный символ \$.\\\\
Далее происходит следующее. Мы достаём символ из строки и нечто со стека.
Если нечто - терминал и совпало с символом, то $pop$
и двигаем текущий символ. Если не совпало - ошибка. (При любой ошибке 
выходим из цикла.)\\
Если же нечто - нетерминал, то мы ищем в таблице запись на пересечении
нечто и текущего символа строки. Если запись не найдена, то ошибка.
Иначе $pop$. 
Правая часть записи добавляется в стек, так что первый её элемент наверху.
\\\\ 
Так повторяется, пока текущий символ не станет концом строки или не 
будет получена ошибка. Если ошибок не было, то строка принадлежит языку.
\\\\
Рассмотрим пример. Грамматика
$$S^{'} \to S\$$$
$$S \to xYzS \ | \ a$$
$$Y \to xYz \ | \ y$$
и строки $xxyzza$ и $xxyzzz$.\\
Таблица 1:
\begin{center}
  \begin{tabular}{ c|c|c }
    NT & FIRST & FOLLOW         \\
    \hline
    $S^{'}$ &  x,a & \$          \\
    \hline
    S &  x,a & \$    \\
    \hline
    Y &  x,y & z,\$       
  \end{tabular}
\end{center}
Таблица 2:
\begin{center}
  \begin{tabular}{ c|c|c|c|c|c }
    NT/T & a          & x            & y & z & \$  \\
    \hline
    $S^{'}$    & $S^{'} \to S\$$ & $S^{'} \to S\$$  &   &   &        \\
    \hline
    S    &  $S \to a$   &  $S \to xYzS$ &  &   &     \\
    \hline
    Y    & & $Y \to xYz$  & $Y \to y$  &   &        
  \end{tabular}
\end{center}
Начинаем разбор строки $xxyzza$:\\\\
Стек: $S^{'}$\\
Строка: $xxyzza\$$\\
Символ: x\\
Нечто - $S^{'}$\\
Нечто - нетерминал, и потому ищем пересечение $S^{'}$ и x. 
Находим $S^{'} \to S\$$.\\
Стек: $\$S$\\
\\
Строка: $xxyzza\$$\\
Символ: x\\
Нечто - $S$\\
Нечто - нетерминал, и потому ищем пересечение $S$ и x. 
Находим $S \to xYzS$.\\
Стек: $\$SzYx$\\
\\
Строка: $xxyzza\$$\\
Символ: x\\
Нечто - x\\
Нечто - терминал, и он совпал с текущим символом.\\
Стек: $\$SzY$\\
Строка: $xyzza\$$\\
\\
Символ: x\\
Нечто - Y\\
Нечто - нетерминал, и потому ищем пересечение $Y$ и x. 
Находим $Y \to xYz$.\\
Стек: $\$SzzYx$\\
\\
Строка: $xyzza\$$\\
Символ: x\\
Нечто - x\\
Нечто - терминал, и он совпал с текущим символом.\\
Стек: $\$SzzY$\\
Строка: $yzza\$$\\
\\
Символ: y\\
Нечто - Y\\
Нечто - нетерминал, и потому ищем пересечение $Y$ и y. 
Находим $Y \to y$.\\
Стек: $\$Szzy$\\
\\
Строка: $yzza\$$\\
Символ: y\\
Нечто - y\\
Нечто - терминал, и он совпал с текущим символом.\\
Стек: $\$Szz$\\
Строка: $zza\$$\\
\\
Символ: z\\
Нечто - z\\
Нечто - терминал, и он совпал с текущим символом.\\
Стек: $\$Sz$\\
Строка: $za\$$\\
\\
Символ: z\\
Нечто - z\\
Нечто - терминал, и он совпал с текущим символом.\\
Стек: $\$S$\\
Строка: $a\$$\\
\\
Символ: a\\
Нечто - S\\
Нечто - нетерминал, и потому ищем пересечение $S$ и a. 
Находим $S \to a$.\\
Стек: $\$a$\\
\\
Строка: $a\$$\\
Символ: a\\
Нечто - a\\
Нечто - терминал, и он совпал с текущим символом.\\
Стек: $\$$\\
Строка: $\$$\\
\\
Символ: \$\\
Нечто - \$\\
Нечто - \$, и он совпал с текущим символом.\\
Стек: $\empty$\\
Строка: $\empty$\\
\\
Стек опустел, значит цикл закончился. Ошибки не было, посему строка $xxyzza$
принадлежит языку.\\
\\
Теперь строка $xxyzzz$. Здесь всё то же самое до момента:\\\\
Стек: $\$Sz$\\
Строка: $zz\$$\\
\\
Символ: z\\
Нечто - z\\
Нечто - терминал, и он совпал с текущим символом.\\
Стек: $\$S$\\
Строка: $z\$$\\
\\
Символ: z\\
Нечто - S\\
Нечто - нетерминал, и потому ищем пересечение $S$ и z. Не нашли. ОШИБКА.
Выходим.\\
Таким образом, строка $xxyzzz$ не принадлежит языку.
\part{LR(0): то, ради чего мы сюда пришли}
Мы преодолели долгий путь, но тут на нас напали конечные автоматы. 
Присаживайтесь поудобнее, сейчас начнётся реальная мясорубка.\\
LR-челики строятся на двух основных операциях: сдвиг и свертка:\\\\
Сдвиг:\\
Стек: aBC, Строка: def\\
Стек: aBCd, Строка: ef\\
\\
Cвертка (предполагая правило A->BC):\\
Стек: aBC\\
Стек: aA\\
\\
Вся сложность парсинга состоит в том, что произвольную строку не спарсить, 
тыкая наугад либо сдвиг либо свертку. Последовательностей действий 
может быть разной, и какая-то будет успешной, а какая-то нет (это как 
игра в карты, непонятно когда какую карту выложить, а когда придержать). 
Вообще, ТА - то ещё казино. Особенно когда грамматика некорректная.
Ну да ладно.\\
Короче, какой-то больной на голову человек придумал анализировать сдвиги
через ввод дополнительного символа. В разных источниках его обозначают
по-разному, мы будем использовать \_. Производящее правило 
с \_ в правой части правила называется LR(0)-ситуацией.\\
Рассмотрим грамматику
$$S\to TF$$
$$F\to +T$$
$$T\to a \ | \ (F)$$
Поехали строить LR(0) состояния. Изначально вспомогательный символ 
всегда находится в начале правой части производящего правила.
$$S\to \_TF$$
Далее рекурсивно повторяем это для нетерминала перед \_, в данном случае T.
$$T\to \_a, \ T\to \_(F)$$
Итак, $1. \ S\to \_TF, \ T\to \_a, \ T\to \_(F)$.\\\\
Теперь двигаем \_ во всех LR(0)-ситуациях. Сдвиг относительно 
каждого отдельного терминала или нетерминала порождает новое состояние.
$$2. \ S\to T\_F$$
$$3. \ T\to a\_$$
$$4. \ T\to (\_F)$$
2е и 4е состояния порождает ситуацию \_NT, так что опять плодят в себе
другие состояния:
$$\ F\to \_+T$$
В итоге
$$2. \ S\to T\_F, \ F\to \_+T$$
$$3. \ T\to a\_$$
$$4. \ T\to (\_F), \ F\to \_+T$$
Далее из 2
$$5. \ S\to TF\_$$
$$6. \ F\to +\_T, \ T\to \_a, \ T\to \_(F)$$
Из 4
$$7. \ T\to (F\_)$$
Из 6
$$8. \ F\to +T\_$$
Из 7
$$9.\ T\to (F)\_$$
Соберём состояния воедино:
$$1. \ T\to \_a, \ T\to \_(F), \ S\to \_TF$$
$$2. \ F\to \_+T, \ S\to T\_F $$
$$3. \ T\to a\_$$
$$4. \ T\to (\_F), \ F\to \_+T$$
$$5. \ S\to TF\_$$
$$6. \ F\to +\_T, \ T\to \_a, \ T\to \_(F)$$
$$7. \ T\to (F\_)$$
$$8. \ F\to +T\_$$
$$9.\ T\to (F)\_$$
\begin{center}
  \begin{tabular}{ c|c | c|c|c|c|c|c }
    Сост/Элм & a & + & ( & ) & конец & F & T \\
    \hline
    1    & сдвиг 3 &  & сдвиг 4  &   & &  & сдвиг 2 \\
    \hline
    2    &  & сдвиг 6 &  &   &  & сдвиг 5 & \\
    \hline
    3    свертка $T\to a$ \\
    \hline
    4    & &  &  &   &  & сдвиг 7 &  \\
    \hline
    5   & & & & & свертка $S\to TF$, успех &  \\
    \hline
    6    & &  &   &   &  & & сдвиг 8\\ 
    \hline
    7    & &  &  &   & & сдвиг 9  & \\
    \hline
    8   свертка $F\to +T$  \\
    \hline
    9  свертка $T\to (F)$    \\  
  \end{tabular}
\end{center}
Таким образом, таблица парсинга LR(0) построена. 
\end{document}

